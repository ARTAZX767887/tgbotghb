import asyncio
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import re
from typing import List, Dict
import json
import os

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO)
logger = logging.getLogger(__name__)


class AddressBot:

    def __init__(self, token: str, admin_id: int):
        self.token = token
        self.admin_id = admin_id
        self.addresses = []
        self.data_file = "addresses.json"
        self.txt_files_dir = "data"
        self.create_data_directory()
        self.load_addresses_from_txt()

    def create_data_directory(self):
        if not os.path.exists(self.txt_files_dir):
            os.makedirs(self.txt_files_dir)
            logger.info(f"Created data directory: {self.txt_files_dir}")

    def load_addresses_from_txt(self):
        self.addresses = []
        if not os.path.exists(self.txt_files_dir):
            logger.warning(
                f"Data directory {self.txt_files_dir} does not exist")
            return

        txt_files = [
            f for f in os.listdir(self.txt_files_dir) if f.endswith('.txt')
        ]
        if not txt_files:
            logger.info("No .txt files found in data directory")
            return

        for txt_file in txt_files:
            file_path = os.path.join(self.txt_files_dir, txt_file)
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    file_addresses = self.parse_addresses(content)
                    self.addresses.extend(file_addresses)
                    logger.info(
                        f"Loaded {len(file_addresses)} addresses from {txt_file}"
                    )
            except Exception as e:
                logger.error(f"Error reading file {txt_file}: {e}")

        logger.info(f"Total addresses loaded: {len(self.addresses)}")
        self.save_addresses()

    def reload_data(self):
        self.load_addresses_from_txt()

    def get_txt_files_info(self):
        if not os.path.exists(self.txt_files_dir):
            return []

        txt_files = [
            f for f in os.listdir(self.txt_files_dir) if f.endswith('.txt')
        ]
        files_info = []
        for txt_file in txt_files:
            file_path = os.path.join(self.txt_files_dir, txt_file)
            try:
                stat = os.stat(file_path)
                files_info.append({
                    'name': txt_file,
                    'size': stat.st_size,
                    'modified': stat.st_mtime
                })
            except Exception as e:
                logger.error(f"Error getting info for {txt_file}: {e}")
        return files_info

    def save_addresses(self):
        try:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.addresses, f, ensure_ascii=False, indent=2)
            logger.info(f"Saved {len(self.addresses)} addresses to file")
        except Exception as e:
            logger.error(f"Error saving addresses: {e}")

    def parse_addresses(self, text: str) -> List[Dict]:
        addresses = []
        lines = text.strip().split('\n')
        for line in lines:
            if not line.strip():
                continue
            parts = line.split('\t')
            if len(parts) >= 4:
                date = parts[0].strip()
                start_time = parts[1].strip()
                end_time = parts[2].strip()
                category = parts[3].strip()
                address = parts[4].strip() if len(parts) > 4 else ""
                addresses.append({
                    'date': date,
                    'start_time': start_time,
                    'end_time': end_time,
                    'category': category,
                    'address': address,
                    'full_text': line
                })
                logger.debug(f"Parsed address: {address}")
        return addresses

    def search_addresses(self, query: str) -> List[Dict]:
        """Search for addresses containing all words in the query string"""
        results = []
        query_words = [
            word.strip().lower() for word in query.split() if word.strip()
        ]
        if not query_words:
            logger.warning("Empty query received")
            return results

        logger.info(f"Searching for query: {query_words}")
        for addr in self.addresses:
            address_lower = addr['address'].lower()
            # Check if all query words are present in the address
            if all(word in address_lower for word in query_words):
                results.append(addr)
                logger.debug(f"Match found: {addr['address']}")
            else:
                logger.debug(
                    f"No match for {addr['address']} with query {query_words}")
        logger.info(f"Found {len(results)} matches for query: {query_words}")
        return results

    def is_admin(self, user_id: int) -> bool:
        return user_id == self.admin_id

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if self.is_admin(user_id):
            files_info = self.get_txt_files_info()
            files_count = len(files_info)
            welcome_message = f"""
ğŸ”§ Ø³Ù„Ø§Ù… Ø§Ø¯Ù…ÛŒÙ† Ø¹Ø²ÛŒØ²!

Ø´Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯:
/reload - Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt
/files - Ù†Ù…Ø§ÛŒØ´ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
/status - ÙˆØ¶Ø¹ÛŒØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
/help - Ø±Ø§Ù‡Ù†Ù…Ø§

ğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt: {files_count}
ğŸ“Š Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡: {len(self.addresses)} Ø¢Ø¯Ø±Ø³

ğŸ’¡ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† Ø¯Ø§Ø¯Ù‡ Ø¬Ø¯ÛŒØ¯ØŒ ÙØ§ÛŒÙ„ .txt Ø±Ø§ Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯ Ùˆ /reload Ø¨Ø²Ù†ÛŒØ¯.
            """
        else:
            if len(self.addresses) == 0:
                welcome_message = """
âŒ Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ù‡Ù†ÙˆØ² Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ø³ÛŒØ³ØªÙ… ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.
Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ù†ÛŒØ¯.
                """
            else:
                welcome_message = """
ğŸ” Ø³Ù„Ø§Ù…! Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø¬Ø³ØªØ¬ÙˆÛŒ Ù‚Ø·Ø¹ÛŒ Ø¨Ø±Ù‚ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯

Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬ÙˆØŒ Ù†Ø§Ù… Ø®ÛŒØ§Ø¨Ø§Ù†ØŒ Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ù…Ù†Ø·Ù‚Ù‡ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ù†Ø¯ Ú©Ù„Ù…Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ø§Ù„: "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù† Ø¨Ù‡Ø§Ø±").

Ù…Ø«Ø§Ù„: "Ø®Ø²Ø±" ÛŒØ§ "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù† Ø¨Ù‡Ø§Ø±" ÛŒØ§ "Ù…Ø¹Ù„Ù…"

ğŸ“Š ØªØ¹Ø¯Ø§Ø¯ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯: {}
                """.format(len(self.addresses))
        await update.message.reply_text(welcome_message)

    async def help_command(self, update: Update,
                           context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if self.is_admin(user_id):
            help_text = """
ğŸ“– Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†:

ğŸ”§ Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†:
/reload - Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt
/files - Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
/status - Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª Ùˆ Ø¢Ù…Ø§Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§

ğŸ“ Ù†Ø­ÙˆÙ‡ Ø§ÙØ²ÙˆØ¯Ù† Ø¯Ø§Ø¯Ù‡:
1. ÙØ§ÛŒÙ„ .txt Ø±Ø§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¯Ø± Ø±Ø¨Ø§Øª Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯
2. Ø¯Ø³ØªÙˆØ± /reload Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯
3. Ø±Ø¨Ø§Øª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡ Ø±Ø§ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

ğŸ“Š ÙØ±Ù…Øª ÙØ§ÛŒÙ„ .txt:
Ù‡Ø± Ø®Ø·: ØªØ§Ø±ÛŒØ® [TAB] Ø²Ù…Ø§Ù†_Ø´Ø±ÙˆØ¹ [TAB] Ø²Ù…Ø§Ù†_Ù¾Ø§ÛŒØ§Ù† [TAB] Ø¯Ø³ØªÙ‡ [TAB] Ø¢Ø¯Ø±Ø³
            """
        else:
            help_text = """
ğŸ“– Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†:

ğŸ” Ù†Ø­ÙˆÙ‡ Ø¬Ø³ØªØ¬Ùˆ:
- Ù†Ø§Ù… Ø®ÛŒØ§Ø¨Ø§Ù†ØŒ Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ù…Ù†Ø·Ù‚Ù‡ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯
- Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ±ØŒ Ú†Ù†Ø¯ Ú©Ù„Ù…Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ø§Ù„: "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù† Ø¨Ù‡Ø§Ø±")
- Ø±ÙˆÛŒ Ù†ØªØ§ÛŒØ¬ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ Ø¬Ø²Ø¦ÛŒØ§Øª Ø±Ø§ Ø¨Ø¨ÛŒÙ†ÛŒØ¯

ğŸ’¡ Ù†Ú©Ø§Øª:
- Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø®Ø´ÛŒ Ø§Ø² Ù†Ø§Ù… Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯
- Ø¬Ø³ØªØ¬Ùˆ Ø­Ø³Ø§Ø³ Ø¨Ù‡ Ø­Ø±ÙˆÙ Ú©ÙˆÚ†Ú©/Ø¨Ø²Ø±Ú¯ Ù†ÛŒØ³Øª
- Ú†Ù†Ø¯ Ú©Ù„Ù…Ù‡ Ø±Ø§ Ø¨Ø§ ÙØ§ØµÙ„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ØªØ§ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ø´Ø§Ù…Ù„ Ù‡Ù…Ù‡ Ø¢Ù†â€ŒÙ‡Ø§ Ù‡Ø³ØªÙ†Ø¯ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆÙ†Ø¯
            """
        await update.message.reply_text(help_text)

    async def reload_command(self, update: Update,
                             context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text(
                "âŒ Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ù†ÛŒØ³ØªÛŒØ¯.")
            return
        await update.message.reply_text("ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§...")
        old_count = len(self.addresses)
        self.reload_data()
        new_count = len(self.addresses)
        files_info = self.get_txt_files_info()
        message = f"""
âœ… Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯ Ú©Ø§Ù…Ù„ Ø´Ø¯!

ğŸ“Š Ø¢Ù…Ø§Ø±:
â€¢ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ: {old_count}
â€¢ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯: {new_count}
â€¢ ØªØºÛŒÛŒØ±Ø§Øª: {new_count - old_count:+d}
â€¢ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt: {len(files_info)}

ğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯Ù‡:
"""
        for file_info in files_info:
            message += f"â€¢ {file_info['name']} ({file_info['size']} Ø¨Ø§ÛŒØª)\n"
        await update.message.reply_text(message)

    async def files_command(self, update: Update,
                            context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text(
                "âŒ Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ù†ÛŒØ³ØªÛŒØ¯.")
            return
        files_info = self.get_txt_files_info()
        if not files_info:
            await update.message.reply_text("""
ğŸ“ Ù‡ÛŒÚ† ÙØ§ÛŒÙ„ .txt Ø¯Ø± Ù¾ÙˆØ´Ù‡ 'data' ÛŒØ§ÙØª Ù†Ø´Ø¯.

ğŸ’¡ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† Ø¯Ø§Ø¯Ù‡:
1. ÙØ§ÛŒÙ„ .txt Ø±Ø§ Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯
2. Ø¯Ø³ØªÙˆØ± /reload Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯
            """)
            return
        import time
        message = f"ğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt Ù…ÙˆØ¬ÙˆØ¯ ({len(files_info)} ÙØ§ÛŒÙ„):\n\n"
        for file_info in files_info:
            modified_date = time.strftime(
                '%Y/%m/%d %H:%M', time.localtime(file_info['modified']))
            size_kb = file_info['size'] / 1024
            message += f"""
ğŸ“„ {file_info['name']}
   ğŸ“Š Ø­Ø¬Ù…: {size_kb:.1f} Ú©ÛŒÙ„ÙˆØ¨Ø§ÛŒØª
   ğŸ“… Ø¢Ø®Ø±ÛŒÙ† ØªØºÛŒÛŒØ±: {modified_date}
"""
        message += f"\nğŸ’¡ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯: /reload"
        await update.message.reply_text(message)

    async def status_command(self, update: Update,
                             context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text(
                "âŒ Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ù†ÛŒØ³ØªÛŒØ¯.")
            return
        dates = {}
        for addr in self.addresses:
            date = addr['date']
            dates[date] = dates.get(date, 0) + 1
        files_info = self.get_txt_files_info()
        status_text = f"""
ğŸ“Š ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…:

ğŸ”¢ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§: {len(self.addresses)}
ğŸ“… ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²Ù‡Ø§: {len(dates)}
ğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt: {len(files_info)}

ğŸ“ˆ Ø¢Ù…Ø§Ø± Ø±ÙˆØ²Ø§Ù†Ù‡:
"""
        for date, count in sorted(dates.items()):
            status_text += f"â€¢ {date}: {count} Ø¢Ø¯Ø±Ø³\n"
        if files_info:
            status_text += f"\nğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯:\n"
            for file_info in files_info:
                status_text += f"â€¢ {file_info['name']}\n"
        await update.message.reply_text(status_text)

    async def clear_data(self, update: Update,
                         context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text(
                "âŒ Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ù†ÛŒØ³ØªÛŒØ¯.")
            return
        txt_files = [
            f for f in os.listdir(self.txt_files_dir) if f.endswith('.txt')
        ]
        for txt_file in txt_files:
            try:
                os.remove(os.path.join(self.txt_files_dir, txt_file))
                logger.info(f"Deleted file: {txt_file}")
            except Exception as e:
                logger.error(f"Error deleting file {txt_file}: {e}")
        self.addresses = []
        self.save_addresses()
        await update.message.reply_text("""
âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .txt Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯.

ğŸ’¡ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† Ø¯Ø§Ø¯Ù‡ Ø¬Ø¯ÛŒØ¯ØŒ ÙØ§ÛŒÙ„ .txt Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯ Ùˆ /reload Ø¨Ø²Ù†ÛŒØ¯.
        """)

    async def cancel_command(self, update: Update,
                             context: ContextTypes.DEFAULT_TYPE):
        context.user_data.clear()
        await update.message.reply_text("âœ… Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.")

    async def handle_file_upload(self, update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text("âŒ Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ø¢Ù¾Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ù†ÛŒØ³ØªÛŒØ¯.")
            return
        document = update.message.document
        if not document.file_name.endswith('.txt'):
            await update.message.reply_text("âŒ Ù„Ø·ÙØ§Ù‹ ÙÙ‚Ø· ÙØ§ÛŒÙ„ .txt Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯."
                                            )
            return
        try:
            file = await document.get_file()
            file_path = os.path.join(self.txt_files_dir, document.file_name)
            counter = 1
            base_name, ext = os.path.splitext(document.file_name)
            while os.path.exists(file_path):
                new_name = f"{base_name}_{counter}{ext}"
                file_path = os.path.join(self.txt_files_dir, new_name)
                counter += 1
            await file.download_to_drive(file_path)
            logger.info(f"File saved: {file_path}")
            await update.message.reply_text(f"""
âœ… ÙØ§ÛŒÙ„ "{document.file_name}" Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯.

ğŸ“Š Ø­Ø¬Ù…: {document.file_size} Ø¨Ø§ÛŒØª
ğŸ’¡ Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ§ÛŒÙ„: /reload
            """)
        except Exception as e:
            logger.error(f"Error handling file upload: {e}")
            await update.message.reply_text(
                "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ ÙØ§ÛŒÙ„. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.")

    async def handle_message(self, update: Update,
                             context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        text = update.message.text

        if len(self.addresses) == 0:
            await update.message.reply_text("""
âŒ Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ù‡Ù†ÙˆØ² Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ø³ÛŒØ³ØªÙ… ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.

ğŸ’¡ Ø§Ú¯Ø± Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø³ØªÛŒØ¯ØŒ ÙØ§ÛŒÙ„ .txt Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ø±Ø¯Ù‡ Ùˆ /reload Ø¨Ø²Ù†ÛŒØ¯.
            """)
            return

        results = self.search_addresses(text)
        if not results:
            query_words = [
                word.strip() for word in text.split() if word.strip()
            ]
            await update.message.reply_text(f"""
âŒ Ø¢Ø¯Ø±Ø³ÛŒ Ø¨Ø§ Ø¹Ø¨Ø§Ø±Øª "{text}" ÛŒØ§ÙØª Ù†Ø´Ø¯.

ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª:
â€¢ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ù‡Ù…Ù‡ Ú©Ù„Ù…Ø§Øª Ø¬Ø³ØªØ¬Ùˆ ({query_words}) Ø¯Ø± Ø¢Ø¯Ø±Ø³ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ù†Ø¯
â€¢ Ú©Ù„Ù…Ù‡ ÛŒØ§ Ú©Ù„Ù…Ø§Øª Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯ (Ù…Ø«Ø§Ù„: "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù† Ø¨Ù‡Ø§Ø±")
â€¢ Ø¨Ø®Ø´ÛŒ Ø§Ø² Ù†Ø§Ù… Ø®ÛŒØ§Ø¨Ø§Ù† ÛŒØ§ Ù…Ù†Ø·Ù‚Ù‡ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯
â€¢ Ø§Ø² Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ù…Ø«Ù„ "Ø®Ø²Ø±"ØŒ "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù†"ØŒ "Ø¨Ù‡Ø§Ø±" Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯
            """)
            return

        if len(results) > 20:
            await update.message.reply_text(f"""
âš ï¸ ØªØ¹Ø¯Ø§Ø¯ Ù†ØªØ§ÛŒØ¬ Ø²ÛŒØ§Ø¯ Ø§Ø³Øª ({len(results)} Ù†ØªÛŒØ¬Ù‡)

Ù„Ø·ÙØ§Ù‹ Ø¹Ø¨Ø§Ø±Øª Ø¯Ù‚ÛŒÙ‚â€ŒØªØ±ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ø§Ù„: "Ù¾Ø§Ø³Ø¯Ø§Ø±Ø§Ù† Ø¨Ù‡Ø§Ø±").
            """)
            return

        keyboard = []
        for i, addr in enumerate(results[:20]):
            preview = addr['address'][:50] + "..." if len(
                addr['address']) > 50 else addr['address']
            button_text = f"ğŸ“ {addr['date']} - {preview}"
            keyboard.append(
                [InlineKeyboardButton(button_text, callback_data=f"addr_{i}")])

        reply_markup = InlineKeyboardMarkup(keyboard)
        context.user_data['search_results'] = results
        await update.message.reply_text(
            f"ğŸ” {len(results)} Ù†ØªÛŒØ¬Ù‡ Ø¨Ø±Ø§ÛŒ \"{text}\" ÛŒØ§ÙØª Ø´Ø¯:\n\nØ±ÙˆÛŒ Ø¢Ø¯Ø±Ø³ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:",
            reply_markup=reply_markup)

    async def button_callback(self, update: Update,
                              context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        if query.data.startswith("addr_"):
            index = int(query.data.split("_")[1])
            results = context.user_data.get('search_results', [])
            if index < len(results):
                addr = results[index]
                response = f"""
ğŸ“ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¢Ø¯Ø±Ø³:

ğŸ“… ØªØ§Ø±ÛŒØ®: {addr['date']}
ğŸ• Ø²Ù…Ø§Ù† Ø´Ø±ÙˆØ¹: {addr['start_time']}
ğŸ•• Ø²Ù…Ø§Ù† Ù¾Ø§ÛŒØ§Ù†: {addr['end_time']}
ğŸ·ï¸ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {addr['category']}
ğŸ—ºï¸ Ø¢Ø¯Ø±Ø³: {addr['address']}
                """
                # Add Return button
                keyboard = [[
                    InlineKeyboardButton("Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="return")
                ]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(response,
                                              reply_markup=reply_markup)
        elif query.data == "return":
            results = context.user_data.get('search_results', [])
            if results:
                keyboard = []
                for i, addr in enumerate(results[:20]):
                    preview = addr['address'][:50] + "..." if len(
                        addr['address']) > 50 else addr['address']
                    button_text = f"ğŸ“ {addr['date']} - {preview}"
                    keyboard.append([
                        InlineKeyboardButton(button_text,
                                             callback_data=f"addr_{i}")
                    ])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(
                    f"ğŸ” {len(results)} Ù†ØªÛŒØ¬Ù‡ ÛŒØ§ÙØª Ø´Ø¯:\n\nØ±ÙˆÛŒ Ø¢Ø¯Ø±Ø³ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:",
                    reply_markup=reply_markup)

    def run(self):
        self.application = Application.builder().token(self.token).build()
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(
            CommandHandler("reload", self.reload_command))
        self.application.add_handler(
            CommandHandler("files", self.files_command))
        self.application.add_handler(
            CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("clear", self.clear_data))
        self.application.add_handler(
            CommandHandler("cancel", self.cancel_command))
        self.application.add_handler(CallbackQueryHandler(
            self.button_callback))
        self.application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND,
                           self.handle_message))
        self.application.add_handler(
            MessageHandler(filters.Document.FileExtension("txt"),
                           self.handle_file_upload))
        print("ğŸ¤– Bot is starting...")
        self.application.run_polling(allowed_updates=Update.ALL_TYPES)


# Configuration
BOT_TOKEN = "8231267816:AAHRHalMg0zyDT5FAiTDB04rIR1HFQlmrt4"
ADMIN_USER_ID = 699591084

if __name__ == "__main__":
    bot = AddressBot(BOT_TOKEN, ADMIN_USER_ID)
    bot.run()
