import logging
import asyncio
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import requests
from bs4 import BeautifulSoup
import re
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOT_TOKEN = "8344260394:AAGcqbk73305XmakKK3HQtEu0IeVsFFYvNM"

class PowerOutageBot:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user = update.effective_user
        welcome_text = (
            f"Ø³Ù„Ø§Ù… {user.first_name}! ðŸ‘‹\n\n"
            "Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù‚Ø·Ø¹ÛŒ Ø¨Ø±Ù‚ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.\n\n"
            "Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ø®ÛŒØ§Ø¨Ø§Ù† Ù…Ø­Ù„ Ø²Ù†Ø¯Ú¯ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:"
        )
        
        await update.message.reply_text(welcome_text)
    
    def search_power_outages(self, street_name):
        try:
            url = "https://khamooshi.maztozi.ir"
            response = self.session.get(url)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            form = soup.find('form')
            if not form:
                return "Ø®Ø·Ø§: ÙØ±Ù… Ø¬Ø³ØªØ¬Ùˆ ÛŒØ§ÙØª Ù†Ø´Ø¯"
            
            # Prepare form data
            form_data = {}
            
            # Find all input fields in the form
            inputs = form.find_all(['input', 'select'])
            for input_field in inputs:
                name = input_field.get('name')
                if name:
                    if input_field.name == 'select':
                        # Handle select fields
                        if 'province' in name.lower() or 'Ø§Ø³ØªØ§Ù†' in str(input_field):
                            # Find the option for Sari (Ø³Ø§Ø±ÛŒ)
                            options = input_field.find_all('option')
                            for option in options:
                                if 'Ø³Ø§Ø±ÛŒ' in option.text or 'sari' in option.text.lower():
                                    form_data[name] = option.get('value', 'Ø³Ø§Ø±ÛŒ')
                                    break
                        elif 'city' in name.lower() or 'Ø´Ù‡Ø±' in str(input_field):
                            form_data[name] = 'Ø³Ø§Ø±ÛŒ'
                    elif input_field.get('type') == 'text':
                        if 'location' in name.lower() or 'Ù…Ú©Ø§Ù†' in str(input_field):
                            form_data[name] = street_name
                    elif input_field.get('type') == 'hidden':
                        form_data[name] = input_field.get('value', '')
            
            # Add the street name to location field
            form_data['location'] = street_name
            form_data['city'] = 'Ø³Ø§Ø±ÛŒ'
            
            # Submit the form
            action = form.get('action', '')
            if not action.startswith('http'):
                action = url + action
            
            search_response = self.session.post(action, data=form_data)
            search_response.raise_for_status()
            
            # Parse the results
            results_soup = BeautifulSoup(search_response.content, 'html.parser')
            
            # Look for results (this may need adjustment based on actual HTML structure)
            results = []
            
            # Try to find result containers (adjust selectors based on actual website)
            result_containers = results_soup.find_all(['div', 'tr', 'li'], 
                                                    class_=re.compile(r'result|item|row', re.I))
            
            if not result_containers:
                # Fallback: look for any element containing the street name
                result_containers = results_soup.find_all(text=re.compile(street_name, re.I))
                result_containers = [elem.parent for elem in result_containers if elem.parent]
            
            for container in result_containers[:10]:  # Limit to 10 results
                text = container.get_text(strip=True)
                if street_name in text:
                    # Try to extract address and time information
                    lines = text.split('\n')
                    address = ""
                    time_info = ""
                    
                    for line in lines:
                        line = line.strip()
                        if line:
                            if any(keyword in line for keyword in ['Ø®ÛŒØ§Ø¨Ø§Ù†', 'Ú©ÙˆÚ†Ù‡', 'Ø¢Ø¯Ø±Ø³']):
                                address = line
                            elif any(keyword in line for keyword in ['Ø³Ø§Ø¹Øª', 'Ø²Ù…Ø§Ù†', 'Ù‚Ø·Ø¹ÛŒ']):
                                time_info = line
                    
                    if address or time_info:
                        results.append({
                            'address': address or text[:100],
                            'time': time_info or 'Ø²Ù…Ø§Ù† Ù…Ø´Ø®Øµ Ù†Ø´Ø¯Ù‡'
                        })
            
            return results
            
        except requests.RequestException as e:
            logger.error(f"Request error: {e}")
            return f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ ÙˆØ¨â€ŒØ³Ø§ÛŒØª: {str(e)}"
        except Exception as e:
            logger.error(f"General error: {e}")
            return f"Ø®Ø·Ø§: {str(e)}"
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle user messages (street names)"""
        street_name = update.message.text.strip()
        
        if not street_name:
            await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ø®ÛŒØ§Ø¨Ø§Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.")
            return
        
        # Send "searching" message
        searching_msg = await update.message.reply_text(
            f"ðŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù‚Ø·Ø¹ÛŒ Ø¨Ø±Ù‚ Ø¨Ø±Ø§ÛŒ: {street_name}\n"
            "Ù„Ø·ÙØ§Ù‹ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯..."
        )
        
        # Search for power outages
        results = self.search_power_outages(street_name)
        
        # Delete searching message
        await searching_msg.delete()
        
        if isinstance(results, str):
            # Error message
            await update.message.reply_text(f"âŒ {results}")
        elif not results:
            await update.message.reply_text(
                f"âŒ Ù‡ÛŒÚ† Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ '{street_name}' ÛŒØ§ÙØª Ù†Ø´Ø¯.\n"
                "Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ø®ÛŒØ§Ø¨Ø§Ù† Ø±Ø§ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."
            )
        else:
            # Format and send results
            response_text = f"ðŸ“ Ù†ØªØ§ÛŒØ¬ Ø¨Ø±Ø§ÛŒ '{street_name}':\n\n"
            
            for i, result in enumerate(results, 1):
                response_text += f"{i}. ðŸ“ Ø¢Ø¯Ø±Ø³: {result['address']}\n"
                response_text += f"   â° Ø²Ù…Ø§Ù† Ù‚Ø·Ø¹ÛŒ: {result['time']}\n\n"
            
            # Split long messages if needed
            if len(response_text) > 4000:
                parts = [response_text[i:i+4000] for i in range(0, len(response_text), 4000)]
                for part in parts:
                    await update.message.reply_text(part)
            else:
                await update.message.reply_text(response_text)
        
        # Ask for another search
        await update.message.reply_text(
            "Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¬Ø¯Ø¯ØŒ Ù†Ø§Ù… Ú©ÙˆÚ†Ù‡ ÛŒØ§ Ø®ÛŒØ§Ø¨Ø§Ù† Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )

def main():
    """Start the bot"""
    # Create bot instance
    bot = PowerOutageBot()
    
    # Create application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", bot.start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))
    
    # Start the bot
    print("Bot starting...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
